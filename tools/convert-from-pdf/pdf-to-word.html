<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced PDF to Word Converter | FilePro</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link rel="stylesheet" href="../../style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <style>
    :root {
      --primary-color: #4361ee;
      --secondary-color: #3a0ca3;
      --accent-color: #4cc9f0;
      --success-color: #2ecc71;
      --danger-color: #e74c3c;
      --light-color: #f8f9fa;
      --dark-color: #212529;
      --text-color: #333;
      --text-light: #6c757d;
    }
    
    /* Professional Effects */
    .upload-section {
      background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
      border-radius: 15px;
      padding: 30px;
      margin: 20px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
      transition: all 0.5s ease;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .upload-section:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 35px rgba(0,0,0,0.4);
    }

    .upload-section::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
      transform: rotate(45deg);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%) rotate(45deg); }
      100% { transform: translateX(100%) rotate(45deg); }
    }

    .file-drop-zone {
      border: 3px dashed rgba(255,255,255,0.5);
      border-radius: 15px;
      padding: 40px;
      text-align: center;
      background: rgba(255,255,255,0.1);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      z-index: 1;
      backdrop-filter: blur(10px);
      min-height: 200px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .file-drop-zone:hover {
      border-color: rgba(255,255,255,0.8);
      background: rgba(255,255,255,0.2);
      transform: scale(1.02);
    }

    .file-drop-zone.dragover {
      border-color: var(--success-color);
      background: rgba(46, 204, 113, 0.1);
      transform: scale(1.05);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.4); }
      70% { box-shadow: 0 0 0 15px rgba(46, 204, 113, 0); }
      100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
    }

    .file-input-hidden {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .drop-zone-content {
      color: white;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
    }

    .drop-zone-icon {
      font-size: 48px;
      margin-bottom: 15px;
      display: block;
      transition: all 0.3s ease;
    }

    .file-drop-zone:hover .drop-zone-icon {
      transform: scale(1.1);
    }

    .tool-btn {
      background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
      border: none;
      color: white;
      padding: 15px 30px;
      font-size: 16px;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      position: relative;
      z-index: 1;
      margin-top: 20px;
      min-width: 200px;
      font-weight: 600;
      letter-spacing: 0.5px;
      overflow: hidden;
    }

    .tool-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: 0.5s;
    }

    .tool-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }

    .tool-btn:hover::before {
      left: 100%;
    }

    .tool-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .tool-btn:disabled:hover::before {
      left: -100%;
    }

    .progress-container {
      width: 100%;
      background: rgba(255,255,255,0.2);
      border-radius: 10px;
      margin: 20px 0;
      overflow: hidden;
      display: none;
      height: 8px;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 10px;
      position: relative;
    }

    .progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: progressShine 2s infinite;
    }

    @keyframes progressShine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .status-message {
      color: white;
      font-size: 14px;
      margin-top: 10px;
      text-align: center;
      font-weight: 500;
      min-height: 20px;
    }

    #file-info {
      background: rgba(255,255,255,0.1);
      color: white;
      padding: 15px;
      border-radius: 10px;
      margin: 15px 0;
      text-align: center;
      backdrop-filter: blur(10px);
      display: none;
      transition: all 0.3s ease;
      border-left: 4px solid var(--accent-color);
    }

    #file-info:hover {
      transform: translateX(5px);
    }

    #download-section {
      text-align: center;
      margin-top: 20px;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .download-btn {
      background: linear-gradient(45deg, var(--success-color), #27ae60);
      border: none;
      color: white;
      padding: 15px 30px;
      font-size: 16px;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      text-decoration: none;
      display: inline-block;
      min-width: 200px;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }

    .download-btn::after {
      content: 'â†“';
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: all 0.3s ease;
    }

    .download-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
      color: white;
      text-decoration: none;
      padding-right: 50px;
    }

    .download-btn:hover::after {
      opacity: 1;
      right: 30px;
    }

    .instructions {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      margin: 20px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }

    .instructions:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }

    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .feature-card {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      border: 1px solid rgba(255,255,255,0.1);
      position: relative;
      overflow: hidden;
    }

    .feature-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
    }

    .feature-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
      background: rgba(255,255,255,0.15);
    }

    .feature-icon {
      font-size: 2.5em;
      margin-bottom: 15px;
      color: var(--accent-color);
      transition: all 0.3s ease;
    }

    .feature-card:hover .feature-icon {
      transform: scale(1.1);
      color: white;
    }

    .feature-card h3 {
      margin: 10px 0;
      color: white;
    }

    .feature-card p {
      color: rgba(255,255,255,0.8);
      font-size: 0.9em;
    }

    .error-message {
      background: rgba(231, 76, 60, 0.1);
      color: #ff6b6b;
      padding: 15px;
      border-radius: 10px;
      margin: 10px 0;
      border: 1px solid rgba(231, 76, 60, 0.3);
      display: none;
      animation: shake 0.5s ease;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-5px); }
      40%, 80% { transform: translateX(5px); }
    }

    .success-message {
      background: rgba(46, 204, 113, 0.1);
      color: #2ecc71;
      padding: 15px;
      border-radius: 10px;
      margin: 10px 0;
      border: 1px solid rgba(46, 204, 113, 0.3);
      display: none;
      animation: fadeIn 0.5s ease;
    }

    /* Advanced options section */
    .options-section {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }

    .options-section h3 {
      color: white;
      margin-top: 0;
      display: flex;
      align-items: center;
    }

    .options-section h3 i {
      margin-right: 10px;
      color: var(--accent-color);
    }

    .option-row {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 15px 0;
    }

    .option-item {
      flex: 1;
      min-width: 200px;
    }

    .option-item label {
      display: block;
      color: rgba(255,255,255,0.8);
      margin-bottom: 8px;
      font-size: 0.9em;
    }

    .option-item select, .option-item input {
      width: 100%;
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.2);
      color: white;
      font-size: 0.9em;
    }

    .option-item select:focus, .option-item input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.3);
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .upload-section {
        padding: 20px;
      }
      
      .file-drop-zone {
        padding: 30px 20px;
      }
      
      .feature-grid {
        grid-template-columns: 1fr;
      }
      
      .tool-btn, .download-btn {
        width: 100%;
      }
    }

    /* Floating action button */
    .fab {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 60px;
      height: 60px;
      background: var(--primary-color);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
    }

    .fab:hover {
      transform: translateY(-5px) scale(1.1);
      background: var(--secondary-color);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }

    /* Tooltip */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: rgba(0,0,0,0.8);
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.8em;
      font-weight: normal;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 5px;
      z-index: 1000;
      display: none;
      animation: fadeInUp 0.5s ease;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateX(-50%) translateY(20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Floating notification */
    .floating-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px;
      border-radius: 5px;
      z-index: 1000;
      display: none;
      animation: slideInRight 0.5s ease;
      max-width: 300px;
    }

    @keyframes slideInRight {
      from { opacity: 0; transform: translateX(100%); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* Preview section */
    .preview-section {
      margin: 20px 0;
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }

    .preview-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-top: 15px;
    }

    .preview-column {
      flex: 1;
      min-width: 300px;
    }

    .preview-title {
      color: white;
      margin-bottom: 10px;
      font-size: 1.1em;
      display: flex;
      align-items: center;
    }

    .preview-title i {
      margin-right: 10px;
      color: var(--accent-color);
    }

    .preview-content {
      background: white;
      border-radius: 8px;
      padding: 15px;
      height: 300px;
      overflow-y: auto;
      color: var(--dark-color);
      font-family: Arial, sans-serif;
      position: relative;
    }

    .preview-content img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
    }

    .preview-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 10px 0;
    }

    .preview-content table, .preview-content th, .preview-content td {
      border: 1px solid #ddd;
    }

    .preview-content th, .preview-content td {
      padding: 8px;
      text-align: left;
    }

    .preview-content th {
      background-color: #f2f2f2;
    }

    /* OCR progress indicator */
    .ocr-progress {
      display: none;
      margin-top: 10px;
      color: white;
      font-size: 0.9em;
    }

    /* Layout analysis visualization */
    .layout-visualization {
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 10px;
      background: rgba(0,0,0,0.2);
    }

    .layout-block {
      position: relative;
      margin: 5px 0;
      padding: 5px;
      border-radius: 4px;
      background: rgba(76, 201, 240, 0.2);
      border: 1px dashed rgba(76, 201, 240, 0.5);
    }

    .layout-block-title {
      font-size: 0.8em;
      color: var(--accent-color);
      margin-bottom: 3px;
    }
  </style>
</head>
<body>
  <header>
    <div class="logo"><i class="fas fa-bolt"></i> FilePro</div>
    <nav>
      <a href="../../index.html"><i class="fas fa-home"></i> Home</a>
      <a href="../../tools.html"><i class="fas fa-tools"></i> Tools</a>
      <a href="../../about.html"><i class="fas fa-info-circle"></i> About</a>
      <a href="../../contact.html"><i class="fas fa-envelope"></i> Contact</a>
    </nav>
  </header>

  <div class="page">
    <h1><i class="fas fa-file-pdf"></i> PDF to Word Converter</h1>
    <p class="subtitle">Convert your PDF files to editable Word documents with professional formatting preserved.</p>

    <!-- File Upload Section -->
    <div class="upload-section">
      <div class="file-drop-zone" id="dropZone">
        <input type="file" id="pdf-upload" accept=".pdf" class="file-input-hidden" onchange="handleFileSelect(this.files)" />
        <div class="drop-zone-content">
          <span class="drop-zone-icon"><i class="fas fa-cloud-upload-alt"></i></span>
          <div>Drag & drop your PDF here or click to browse</div>
          <small style="opacity: 0.8; margin-top: 10px; display: block;">Supports PDF files up to 50MB</small>
        </div>
      </div>
      
      <div id="file-info"></div>
      
      <div class="error-message" id="error-message"></div>
      <div class="success-message" id="success-message"></div>
      
      <div class="progress-container" id="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      
      <div class="status-message" id="status-message"></div>
      
      <button class="tool-btn" id="convert-btn" onclick="convertPDFToWord()" disabled>
        <span id="convert-btn-text"><i class="fas fa-exchange-alt"></i> Convert to Word</span>
      </button>
    </div>

    <!-- Preview Section -->
    <div class="preview-section" id="preview-section" style="display: none;">
      <h3><i class="fas fa-eye"></i> Document Preview</h3>
      <p>Preview of the extracted content before conversion</p>
      
      <div class="preview-container">
        <div class="preview-column">
          <div class="preview-title"><i class="fas fa-file-pdf"></i> Original PDF Content</div>
          <div class="preview-content" id="pdf-preview"></div>
        </div>
        <div class="preview-column">
          <div class="preview-title"><i class="fas fa-file-word"></i> Word Output Preview</div>
          <div class="preview-content" id="word-preview"></div>
        </div>
      </div>
      
      <div class="layout-visualization" id="layout-visualization" style="display: none;">
        <h4><i class="fas fa-project-diagram"></i> Document Layout Analysis</h4>
        <div id="layout-blocks"></div>
      </div>
    </div>

    <!-- Advanced Options Section -->
    <div class="options-section">
      <h3><i class="fas fa-cog"></i> Conversion Options</h3>
      <div class="option-row">
        <div class="option-item">
          <label for="output-format">Output Format:</label>
          <select id="output-format">
            <option value="docx">DOCX (Word Document)</option>
            <option value="rtf">RTF (Rich Text Format)</option>
            <option value="txt">Plain Text (TXT)</option>
          </select>
        </div>
        <div class="option-item">
          <label for="image-quality">Image Quality (if any):</label>
          <select id="image-quality">
            <option value="high">High Quality</option>
            <option value="medium" selected>Medium Quality</option>
            <option value="low">Low Quality</option>
          </select>
        </div>
      </div>
      <div class="option-row">
        <div class="option-item">
          <label for="page-range">Page Range (e.g., 1-3,5):</label>
          <input type="text" id="page-range" placeholder="All pages" />
        </div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="preserve-layout" checked /> Preserve Layout
          </label>
          <label>
            <input type="checkbox" id="extract-images" /> Extract Images
          </label>
        </div>
      </div>
      <div class="option-row">
        <div class="option-item">
          <label>
            <input type="checkbox" id="enable-ocr" /> Enable OCR (for scanned PDFs)
          </label>
          <div class="ocr-progress" id="ocr-progress"></div>
        </div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="detect-tables" checked /> Detect Tables
          </label>
          <label>
            <input type="checkbox" id="preserve-headers" checked /> Preserve Headers/Footers
          </label>
        </div>
      </div>
    </div>

    <!-- Download Link Section -->
    <div id="download-section" style="display: none;">
      <div class="success-message" style="display: block;">
        <i class="fas fa-check-circle"></i> Conversion successful! Your file is ready to download.
      </div>
      <a id="download-link" href="#" class="download-btn">
        <i class="fas fa-file-word"></i> Download Word Document
      </a>
      <button class="tool-btn" id="convert-another-btn" onclick="resetConverter()" style="background: linear-gradient(45deg, #6c5ce7, #a29bfe); margin-left: 15px;">
        <i class="fas fa-redo"></i> Convert Another File
      </button>
    </div>

    <!-- Features Section -->
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-icon"><i class="fas fa-rocket"></i></div>
        <h3>Fast Conversion</h3>
        <p>Convert PDF to Word in seconds with our optimized processing engine</p>
      </div>
      <div class="feature-card">
        <div class="feature-icon"><i class="fas fa-bullseye"></i></div>
        <h3>High Accuracy</h3>
        <p>Preserve formatting, images, tables and text structure with precision</p>
      </div>
      <div class="feature-card">
        <div class="feature-icon"><i class="fas fa-lock"></i></div>
        <h3>Secure Process</h3>
        <p>Files are processed locally in your browser - no server uploads needed</p>
      </div>
      <div class="feature-card">
        <div class="feature-icon"><i class="fas fa-cogs"></i></div>
        <h3>Advanced Options</h3>
        <p>Customize output with page ranges, format options and quality settings</p>
      </div>
    </div>

    <!-- Instructions Section -->
    <section class="instructions">
      <h2><i class="fas fa-question-circle"></i> How to Convert PDF to Word</h2>
      <ol>
        <li>Drag and drop your PDF file into the upload area, or click to browse your files</li>
        <li>Adjust conversion options if needed (format, quality, page range)</li>
        <li>Click "Convert to Word" to start the conversion process</li>
        <li>Wait for the processing to complete (usually takes a few seconds)</li>
        <li>Download your converted Word document when ready</li>
      </ol>
      
      <h3><i class="fas fa-star"></i> Key Features:</h3>
      <ul>
        <li><i class="fas fa-check-circle" style="color: var(--success-color);"></i> Preserves text formatting and layout</li>
        <li><i class="fas fa-check-circle" style="color: var(--success-color);"></i> Maintains images and graphics (when enabled)</li>
        <li><i class="fas fa-check-circle" style="color: var(--success-color);"></i> Converts tables and lists accurately</li>
        <li><i class="fas fa-check-circle" style="color: var(--success-color);"></i> Supports multi-page documents</li>
        <li><i class="fas fa-check-circle" style="color: var(--success-color);"></i> Works with files up to 50MB</li>
        <li><i class="fas fa-check-circle" style="color: var(--success-color);"></i> No file uploads - processing happens in your browser</li>
      </ul>
      
      <div class="tooltip" style="margin-top: 20px; display: inline-block;">
        <button class="tool-btn" style="background: linear-gradient(45deg, #6c5ce7, #a29bfe); padding: 10px 20px; font-size: 14px;">
          <i class="fas fa-lightbulb"></i> Pro Tip
        </button>
        <span class="tooltiptext">For best results with complex PDFs, enable "Preserve Layout" and use DOCX format</span>
      </div>
    </section>
  </div>

  <div class="fab" id="help-fab" onclick="showHelp()">
    <i class="fas fa-question"></i>
  </div>

  <div class="floating-notification" id="notification">
    <div id="notification-content"></div>
  </div>

  <footer>
    <p>&copy; 2025 FilePro. All rights reserved. | <a href="#" style="color: var(--accent-color);">Privacy Policy</a> | <a href="#" style="color: var(--accent-color);">Terms of Service</a></p>
  </footer>

  <script>
    // Global variables
    let selectedFile = null;
    let conversionInProgress = false;
    let extractedContent = {
      text: [],
      images: [],
      tables: [],
      fonts: [],
      layout: [],
      metadata: {}
    };
    
    // Set up PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // DOM elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('pdf-upload');
    const convertBtn = document.getElementById('convert-btn');
    const convertBtnText = document.getElementById('convert-btn-text');
    const fileInfo = document.getElementById('file-info');
    const errorMessage = document.getElementById('error-message');
    const successMessage = document.getElementById('success-message');
    const downloadSection = document.getElementById('download-section');
    const notification = document.getElementById('notification');
    const pdfPreview = document.getElementById('pdf-preview');
    const wordPreview = document.getElementById('word-preview');
    const previewSection = document.getElementById('preview-section');
    const layoutVisualization = document.getElementById('layout-visualization');
    const layoutBlocks = document.getElementById('layout-blocks');
    const ocrProgress = document.getElementById('ocr-progress');
    
    // Initialize event listeners
    function initEventListeners() {
      dropZone.addEventListener('click', () => fileInput.click());
      
      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
      });
      
      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
      });
      
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const files = e.dataTransfer.files;
        handleFileSelect(files);
      });
      
      // Show notification when page loads
      setTimeout(() => {
        showNotification('Drag and drop your PDF file to begin conversion');
      }, 1500);
    }
    
    // Show notification
    function showNotification(message, duration = 3000) {
      const notificationContent = document.getElementById('notification-content');
      notificationContent.innerHTML = message;
      notification.style.display = 'block';
      
      setTimeout(() => {
        notification.style.display = 'none';
      }, duration);
    }
    
    // Show error message
    function showError(message) {
      errorMessage.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${message}`;
      errorMessage.style.display = 'block';
      setTimeout(() => {
        errorMessage.style.display = 'none';
      }, 5000);
    }
    
    // Show success message
    function showSuccess(message) {
      successMessage.innerHTML = `<i class="fas fa-check-circle"></i> ${message}`;
      successMessage.style.display = 'block';
      setTimeout(() => {
        successMessage.style.display = 'none';
      }, 5000);
    }
    
    // Handle file selection
    async function handleFileSelect(files) {
      if (files.length === 0) return;
      
      const file = files[0];
      
      // Validate file type
      if (!file.type.includes('pdf') && !file.name.toLowerCase().endsWith('.pdf')) {
        showError('Please select a valid PDF file.');
        return;
      }
      
      // Validate file size (50MB limit)
      if (file.size > 50 * 1024 * 1024) {
        showError('File size must be less than 50MB.');
        return;
      }
      
      selectedFile = file;
      
      // Display file info with nice formatting
      fileInfo.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 10px;">
          <i class="fas fa-file-pdf" style="font-size: 24px; color: var(--accent-color); margin-right: 10px;"></i>
          <strong style="font-size: 1.1em;">${file.name}</strong>
        </div>
        <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
          <div style="margin: 5px 10px;"><i class="fas fa-weight-hanging"></i> ${(file.size / 1024 / 1024).toFixed(2)} MB</div>
          <div style="margin: 5px 10px;"><i class="fas fa-calendar-alt"></i> ${new Date(file.lastModified).toLocaleDateString()}</div>
          <div style="margin: 5px 10px;"><i class="fas fa-file-alt"></i> PDF Document</div>
        </div>
      `;
      fileInfo.style.display = 'block';
      
      // Enable convert button
      convertBtn.disabled = false;
      convertBtnText.innerHTML = '<i class="fas fa-exchange-alt"></i> Convert to Word';
      
      // Clear any previous errors
      errorMessage.style.display = 'none';
      
      // Show success message
      showSuccess('PDF file ready for conversion!');
      
      // Preview the PDF content
      await previewPDFContent(file);
    }
    
    // Preview PDF content
    async function previewPDFContent(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        
        const loadingTask = pdfjsLib.getDocument({ data: uint8Array });
        const pdf = await loadingTask.promise;
        const numPages = pdf.numPages;
        
        // Reset extracted content
        extractedContent = {
          text: [],
          images: [],
          tables: [],
          fonts: [],
          layout: [],
          metadata: {}
        };
        
        // Get first page for preview
        const page = await pdf.getPage(1);
        const textContent = await page.getTextContent();
        const viewport = page.getViewport({ scale: 1.0 });
        
        // Extract text items with positions
        const textItems = textContent.items.map(item => {
          const tx = pdfjsLib.Util.transform(page.getViewport({ scale: 1.0 }).transform, item.transform);
          const x = tx[4];
          const y = tx[5];
          const width = item.width;
          const height = item.height;
          
          // Store text item with position
          return {
            text: item.str,
            x: x,
            y: y,
            width: width,
            height: height,
            font: item.fontName,
            size: item.height
          };
        });
        
        // Group text items into paragraphs/lines based on position
        const groupedText = groupTextItems(textItems);
        
        // Display preview
        pdfPreview.innerHTML = '';
        wordPreview.innerHTML = '';
        
        // Show PDF preview
        groupedText.forEach(group => {
          const div = document.createElement('div');
          div.textContent = group.text;
          div.style.marginBottom = '10px';
          
          // Apply some basic styling based on text properties
          if (group.font && group.font.includes('Bold')) {
            div.style.fontWeight = 'bold';
          }
          if (group.size > 14) {
            div.style.fontSize = '1.2em';
          }
          
          pdfPreview.appendChild(div);
        });
        
        // Show Word preview (simplified)
        groupedText.forEach(group => {
          const div = document.createElement('div');
          div.textContent = group.text;
          div.style.marginBottom = '10px';
          
          // Simulate Word styling
          if (group.font && group.font.includes('Bold')) {
            div.style.fontWeight = 'bold';
          }
          if (group.size > 14) {
            div.style.fontSize = '1.2em';
            div.style.marginTop = '15px';
          }
          
          wordPreview.appendChild(div);
        });
        
        // Show preview section
        previewSection.style.display = 'block';
        
        // Analyze layout (for visualization)
        analyzeLayout(textItems);
        
      } catch (error) {
        console.error('Preview error:', error);
        showError('Could not preview PDF content. The file may be password protected or corrupted.');
      }
    }
    
    // Group text items into logical blocks
    function groupTextItems(textItems) {
      if (!textItems || textItems.length === 0) return [];
      
      // Sort by Y position (top to bottom) and then by X position (left to right)
      textItems.sort((a, b) => {
        if (Math.abs(a.y - b.y) < a.height / 2) {
          return a.x - b.x;
        }
        return b.y - a.y;
      });
      
      const groups = [];
      let currentGroup = null;
      const lineHeight = textItems[0]?.height || 12;
      
      for (const item of textItems) {
        if (!currentGroup) {
          currentGroup = {
            text: item.text,
            x: item.x,
            y: item.y,
            width: item.width,
            height: item.height,
            font: item.font,
            size: item.size
          };
        } else {
          // Check if this item is part of the current line
          if (Math.abs(item.y - currentGroup.y) < lineHeight * 0.5) {
            currentGroup.text += ' ' + item.text;
            currentGroup.width = item.x + item.width - currentGroup.x;
          } else {
            // New line/paragraph
            groups.push(currentGroup);
            currentGroup = {
              text: item.text,
              x: item.x,
              y: item.y,
              width: item.width,
              height: item.height,
              font: item.font,
              size: item.size
            };
          }
        }
      }
      
      if (currentGroup) {
        groups.push(currentGroup);
      }
      
      return groups;
    }
    
    // Analyze document layout for visualization
    function analyzeLayout(textItems) {
      layoutBlocks.innerHTML = '';
      
      // Group items by type (headings, paragraphs, etc.)
      const groups = groupTextItems(textItems);
      
      // Visualize layout blocks
      groups.forEach((group, index) => {
        const block = document.createElement('div');
        block.className = 'layout-block';
        
        const title = document.createElement('div');
        title.className = 'layout-block-title';
        title.textContent = `Block ${index + 1} (${group.font || 'default'}, ${Math.round(group.size)}pt)`;
        
        const content = document.createElement('div');
        content.textContent = group.text.length > 50 ? group.text.substring(0, 50) + '...' : group.text;
        content.style.fontSize = '0.9em';
        content.style.color = 'rgba(255,255,255,0.7)';
        
        block.appendChild(title);
        block.appendChild(content);
        layoutBlocks.appendChild(block);
      });
      
      layoutVisualization.style.display = 'block';
    }
    
    // Update progress bar
    function updateProgress(percent, message) {
      const progressContainer = document.getElementById('progress-container');
      const progressBar = document.getElementById('progress-bar');
      const statusMessage = document.getElementById('status-message');
      
      progressContainer.style.display = 'block';
      progressBar.style.width = percent + '%';
      statusMessage.innerHTML = `<span class="spinner" style="${percent === 100 ? 'display: none;' : ''}"></span> ${message}`;
      
      if (percent === 100) {
        setTimeout(() => {
          progressBar.style.width = '0%';
          statusMessage.textContent = '';
        }, 1000);
      }
    }
    
    // Reset the converter
    function resetConverter() {
      selectedFile = null;
      fileInput.value = '';
      fileInfo.style.display = 'none';
      downloadSection.style.display = 'none';
      previewSection.style.display = 'none';
      convertBtn.disabled = true;
      convertBtnText.innerHTML = '<i class="fas fa-exchange-alt"></i> Convert to Word';
      document.getElementById('progress-container').style.display = 'none';
      showNotification('Ready for a new PDF file');
    }
    
    // Show help
    function showHelp() {
      showNotification('Drag a PDF file to the drop zone or click to browse your files', 5000);
    }
    
    // Main conversion function
    async function convertPDFToWord() {
      if (!selectedFile || conversionInProgress) return;
      
      try {
        conversionInProgress = true;
        convertBtn.disabled = true;
        convertBtnText.innerHTML = '<span class="spinner"></span> Processing...';
        
        updateProgress(5, 'Initializing converter...');
        
        const arrayBuffer = await selectedFile.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        
        updateProgress(15, 'Loading PDF document...');
        
        const loadingTask = pdfjsLib.getDocument({ data: uint8Array });
        const pdf = await loadingTask.promise;
        const numPages = pdf.numPages;
        
        updateProgress(25, 'Analyzing document structure...');
        
        // Check page range option
        const pageRangeInput = document.getElementById('page-range').value.trim();
        let pagesToConvert = [];
        
        if (pageRangeInput) {
          // Parse page ranges like "1-3,5,7-9"
          const ranges = pageRangeInput.split(',');
          for (const range of ranges) {
            if (range.includes('-')) {
              const [start, end] = range.split('-').map(Number);
              for (let i = start; i <= end; i++) {
                if (i >= 1 && i <= numPages && !pagesToConvert.includes(i)) {
                  pagesToConvert.push(i);
                }
              }
            } else {
              const pageNum = Number(range);
              if (pageNum >= 1 && pageNum <= numPages && !pagesToConvert.includes(pageNum)) {
                pagesToConvert.push(pageNum);
              }
            }
          }
          
          // Sort page numbers
          pagesToConvert.sort((a, b) => a - b);
          
          if (pagesToConvert.length === 0) {
            showError('Invalid page range specified. Converting all pages.');
            pagesToConvert = Array.from({ length: numPages }, (_, i) => i + 1);
          }
        } else {
          // Convert all pages
          pagesToConvert = Array.from({ length: numPages }, (_, i) => i + 1);
        }
        
        updateProgress(30, `Extracting content from ${pagesToConvert.length} pages...`);
        
        // Reset extracted content
        extractedContent = {
          text: [],
          images: [],
          tables: [],
          fonts: [],
          layout: [],
          metadata: {}
        };
        
        // Check if OCR is needed (scanned PDF detection)
        const enableOCR = document.getElementById('enable-ocr').checked;
        let isScannedPDF = false;
        
        // First check if the PDF has selectable text
        const testPage = await pdf.getPage(1);
        const testTextContent = await testPage.getTextContent();
        
        if (testTextContent.items.length === 0 || 
            testTextContent.items.every(item => item.str.trim() === '')) {
          isScannedPDF = true;
        }
        
        // Extract content from each page
        let currentPage = 0;
        
        for (const pageNum of pagesToConvert) {
          currentPage++;
          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale: 1.0 });
          
          updateProgress(30 + (currentPage / pagesToConvert.length) * 50, 
                       `Processing page ${pageNum} (${currentPage} of ${pagesToConvert.length})...`);
          
          // Extract text content
          const textContent = await page.getTextContent();
          
          // Process text items with layout information
          const textItems = textContent.items.map(item => {
            const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
            const x = tx[4];
            const y = tx[5];
            const width = item.width;
            const height = item.height;
            
            return {
              text: item.str,
              x: x,
              y: y,
              width: width,
              height: height,
              font: item.fontName,
              size: item.height
            };
          });
          
          // Group text items into logical blocks (paragraphs, headings, etc.)
          const groupedText = groupTextItems(textItems);
          
          // Detect tables if enabled
          let tables = [];
          if (document.getElementById('detect-tables').checked) {
            tables = detectTables(groupedText);
          }
          
          // Extract images if enabled
          let images = [];
          if (document.getElementById('extract-images').checked) {
            images = await extractImages(page);
          }
          
          // Perform OCR if needed (scanned PDF)
          let ocrText = [];
          if (enableOCR && isScannedPDF) {
            ocrText = await performOCR(page, pageNum);
          }
          
          // Store extracted content
          extractedContent.text.push({
            page: pageNum,
            content: groupedText,
            ocr: ocrText
          });
          
          extractedContent.tables.push({
            page: pageNum,
            tables: tables
          });
          
          extractedContent.images.push({
            page: pageNum,
            images: images
          });
          
          // Extract fonts information
          const fonts = {};
          textContent.items.forEach(item => {
            if (item.fontName) {
              fonts[item.fontName] = {
                size: item.height,
                color: item.color || '#000000'
              };
            }
          });
          
          extractedContent.fonts.push({
            page: pageNum,
            fonts: fonts
          });
        }
        
        updateProgress(85, 'Creating document structure...');
        
        // Get output format
        const outputFormat = document.getElementById('output-format').value;
        let fileContent, fileName, mimeType;
        
        if (outputFormat === 'docx') {
          // Create Word document content with proper XML structure
          fileContent = createWordDocument(extractedContent, selectedFile.name);
          fileName = selectedFile.name.replace('.pdf', '') + '_converted.docx';
          mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        } else if (outputFormat === 'rtf') {
          // Create RTF document
          fileContent = createRtfDocument(extractedContent, selectedFile.name);
          fileName = selectedFile.name.replace('.pdf', '') + '_converted.rtf';
          mimeType = 'application/rtf';
        } else {
          // Plain text - just concatenate all text content
          let fullText = '';
          extractedContent.text.forEach(page => {
            page.content.forEach(group => {
              fullText += group.text + '\n';
            });
            fullText += '\n';
          });
          
          fileContent = fullText;
          fileName = selectedFile.name.replace('.pdf', '') + '_converted.txt';
          mimeType = 'text/plain';
        }
        
        updateProgress(95, 'Finalizing document...');
        
        // For DOCX format, we need to create a ZIP package
        if (outputFormat === 'docx') {
          const zip = new JSZip();
          
          // Add the main document
          zip.file("word/document.xml", fileContent);
          
          // Add required DOCX structure files
          addDocxStructure(zip);
          
          // Add images if any
          if (document.getElementById('extract-images').checked && extractedContent.images.length > 0) {
            addImagesToDocx(zip, extractedContent.images);
          }
          
          // Generate the DOCX file
          const docxBlob = await zip.generateAsync({ 
            type: "blob",
            mimeType: mimeType
          });
          
          // Create download link
          createDownloadLink(docxBlob, fileName, mimeType);
        } else {
          // For RTF and TXT, create a simple Blob
          const blob = new Blob([fileContent], { type: mimeType });
          createDownloadLink(blob, fileName, mimeType);
        }
        
        updateProgress(100, 'Conversion complete!');
        showSuccess('Document converted successfully!');
        
      } catch (error) {
        console.error('Conversion error:', error);
        showError('An error occurred during conversion. Please try again with a different PDF file.');
      } finally {
        conversionInProgress = false;
        convertBtnText.innerHTML = '<i class="fas fa-exchange-alt"></i> Convert to Word';
      }
    }
    
    // Detect tables in text content
    function detectTables(textGroups) {
      // Simple table detection based on aligned columns
      const tables = [];
      let currentTable = null;
      
      // Group text items into potential table rows based on y-position
      const rows = {};
      textGroups.forEach(group => {
        const y = Math.round(group.y);
        if (!rows[y]) {
          rows[y] = [];
        }
        rows[y].push(group);
      });
      
      // Convert rows object to array and sort by y-position (top to bottom)
      const sortedRows = Object.values(rows).sort((a, b) => b[0].y - a[0].y);
      
      // Check if we have at least 2 rows with similar column structure
      if (sortedRows.length >= 2) {
        // Simple check for column alignment
        const firstRow = sortedRows[0];
        const secondRow = sortedRows[1];
        
        // Count columns by x-position grouping
        const columnPositions = firstRow.map(item => Math.round(item.x));
        
        // Check if subsequent rows have similar column structure
        let isTable = true;
        for (let i = 1; i < Math.min(3, sortedRows.length); i++) {
          const row = sortedRows[i];
          if (row.length !== firstRow.length) {
            isTable = false;
            break;
          }
          
          // Check if columns are roughly aligned
          for (let j = 0; j < row.length; j++) {
            if (Math.abs(Math.round(row[j].x) - columnPositions[j]) > 20) {
              isTable = false;
              break;
            }
          }
          
          if (!isTable) break;
        }
        
        if (isTable) {
          // Create table structure
          const table = {
            rows: sortedRows.map(row => ({
              cells: row.map(cell => ({
                text: cell.text,
                x: cell.x,
                y: cell.y,
                width: cell.width,
                height: cell.height
              }))
            })),
            columns: columnPositions.length
          };
          
          tables.push(table);
        }
      }
      
      return tables;
    }
    
    // Extract images from PDF page
    async function extractImages(page) {
      const images = [];
      const ops = await page.getOperatorList();
      
      // Iterate through operators to find image drawing commands
      for (let i = 0; i < ops.fnArray.length; i++) {
        if (ops.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
          const imageName = ops.argsArray[i][0];
          const image = await page.objs.get(imageName);
          
          if (image) {
            // Convert image to data URL
            let imageDataUrl;
            if (image instanceof HTMLCanvasElement) {
              imageDataUrl = image.toDataURL('image/png');
            } else if (image.data) {
              // For PDFImage
              const canvas = document.createElement('canvas');
              canvas.width = image.width;
              canvas.height = image.height;
              const ctx = canvas.getContext('2d');
              
              if (image instanceof pdfjsLib.PDFImage) {
                const imageData = {
                  width: image.width,
                  height: image.height,
                  data: image.getImageData(1.0).data
                };
                ctx.putImageData(imageData, 0, 0);
                imageDataUrl = canvas.toDataURL('image/png');
              }
            }
            
            if (imageDataUrl) {
              images.push({
                dataUrl: imageDataUrl,
                width: image.width,
                height: image.height
              });
            }
          }
        }
      }
      
      return images;
    }
    
    // Perform OCR on a page
    async function performOCR(page, pageNum) {
      const viewport = page.getViewport({ scale: 1.5 });
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      
      // Render PDF page to canvas
      await page.render({
        canvasContext: context,
        viewport: viewport
      }).promise;
      
      // Perform OCR using Tesseract.js
      ocrProgress.style.display = 'block';
      ocrProgress.textContent = `Performing OCR on page ${pageNum}...`;
      
      try {
        const result = await Tesseract.recognize(
          canvas,
          'eng',
          {
            logger: m => {
              if (m.status === 'recognizing text') {
                ocrProgress.textContent = `OCR progress: ${Math.round(m.progress * 100)}%`;
              }
            }
          }
        );
        
        ocrProgress.textContent = `OCR completed for page ${pageNum}`;
        setTimeout(() => {
          ocrProgress.style.display = 'none';
        }, 2000);
        
        return result.data.text;
      } catch (error) {
        console.error('OCR error:', error);
        ocrProgress.textContent = `OCR failed for page ${pageNum}`;
        setTimeout(() => {
          ocrProgress.style.display = 'none';
        }, 2000);
        return '';
      }
    }
    
    // Create download link
    function createDownloadLink(blob, fileName, mimeType) {
      const url = URL.createObjectURL(blob);
      const downloadLink = document.getElementById('download-link');
      
      downloadLink.href = url;
      downloadLink.download = fileName;
      
      // Update button text based on format
      const format = mimeType.includes('wordprocessingml') ? 'Word' : 
                    mimeType.includes('rtf') ? 'RTF' : 'Text';
      downloadLink.innerHTML = `<i class="fas fa-download"></i> Download ${format} Document`;
      
      // Show download section
      downloadSection.style.display = 'block';
      
      // Scroll to download section
      setTimeout(() => {
        downloadSection.scrollIntoView({ behavior: 'smooth' });
      }, 300);
    }
    
    // Create Word document XML with enhanced features
    function createWordDocument(content, fileName) {
      const currentDate = new Date().toLocaleDateString();
      const preserveLayout = document.getElementById('preserve-layout').checked;
      const extractImages = document.getElementById('extract-images').checked;
      
      let docContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <w:body>
    <w:p>
      <w:pPr>
        <w:jc w:val="center"/>
        <w:rPr>
          <w:b/>
          <w:sz w:val="32"/>
        </w:rPr>
      </w:pPr>
      <w:r>
        <w:rPr>
          <w:b/>
          <w:sz w:val="32"/>
        </w:rPr>
        <w:t>Converted from PDF</w:t>
      </w:r>
    </w:p>
    <w:p>
      <w:pPr>
        <w:jc w:val="center"/>
      </w:pPr>
      <w:r>
        <w:t>Original file: ${escapeXml(fileName)}</w:t>
      </w:r>
    </w:p>
    <w:p>
      <w:pPr>
        <w:jc w:val="center"/>
      </w:pPr>
      <w:r>
        <w:t>Converted on: ${currentDate}</w:t>
      </w:r>
    </w:p>
    <w:p/>`;

      // Process each page's content
      content.text.forEach((page, pageIndex) => {
        // Add page heading
        docContent += `
    <w:p>
      <w:pPr>
        <w:rPr>
          <w:b/>
          <w:sz w:val="24"/>
        </w:rPr>
      </w:pPr>
      <w:r>
        <w:rPr>
          <w:b/>
          <w:sz w:val="24"/>
        </w:rPr>
        <w:t>Page ${pageIndex + 1}</w:t>
      </w:r>
    </w:p>`;
        
        // Add OCR text if available
        if (page.ocr && page.ocr.trim()) {
          docContent += `
    <w:p>
      <w:pPr>
        <w:rPr>
          <w:i/>
          <w:color w:val="FF0000"/>
        </w:rPr>
      </w:pPr>
      <w:r>
        <w:rPr>
          <w:i/>
          <w:color w:val="FF0000"/>
        </w:rPr>
        <w:t>OCR Text:</w:t>
      </w:r>
    </w:p>
    <w:p>
      <w:r>
        <w:t>${escapeXml(page.ocr)}</w:t>
      </w:r>
    </w:p>`;
        }
        
        // Process text content
        page.content.forEach(textGroup => {
          // Apply styling based on font properties
          let styleProps = '';
          let runProps = '';
          
          if (textGroup.font) {
            if (textGroup.font.includes('Bold')) {
              runProps += '<w:b/>';
            }
            if (textGroup.font.includes('Italic')) {
              runProps += '<w:i/>';
            }
          }
          
          if (textGroup.size) {
            runProps += `<w:sz w:val="${Math.round(textGroup.size * 2)}"/>`;
          }
          
          if (preserveLayout) {
            // Add indentation based on x-position
            const indent = Math.round(textGroup.x / 20) * 200; // Convert to twips (1/20th of a point)
            if (indent > 0) {
              styleProps += `<w:ind w:left="${indent}"/>`;
            }
          }
          
          docContent += `
    <w:p>
      <w:pPr>
        ${styleProps}
      </w:pPr>
      <w:r>
        <w:rPr>
          ${runProps}
        </w:rPr>
        <w:t>${escapeXml(textGroup.text)}</w:t>
      </w:r>
    </w:p>`;
        });
        
        // Add tables if any
        const pageTables = content.tables.find(t => t.page === page.page)?.tables || [];
        pageTables.forEach(table => {
          docContent += `
    <w:tbl>
      <w:tblPr>
        <w:tblW w:w="5000" w:type="pct"/>
        <w:tblBorders>
          <w:top w:val="single" w:sz="4" w:space="0" w:color="auto"/>
          <w:left w:val="single" w:sz="4" w:space="0" w:color="auto"/>
          <w:bottom w:val="single" w:sz="4" w:space="0" w:color="auto"/>
          <w:right w:val="single" w:sz="4" w:space="0" w:color="auto"/>
          <w:insideH w:val="single" w:sz="4" w:space="0" w:color="auto"/>
          <w:insideV w:val="single" w:sz="4" w:space="0" w:color="auto"/>
        </w:tblBorders>
      </w:tblPr>`;
          
          table.rows.forEach(row => {
            docContent += `
      <w:tr>`;
            
            row.cells.forEach(cell => {
              docContent += `
        <w:tc>
          <w:tcPr>
            <w:tcW w:w="${Math.round(cell.width * 20)}" w:type="dxa"/>
          </w:tcPr>
          <w:p>
            <w:r>
              <w:t>${escapeXml(cell.text)}</w:t>
            </w:r>
          </w:p>
        </w:tc>`;
            });
            
            docContent += `
      </w:tr>`;
          });
          
          docContent += `
    </w:tbl>`;
        });
        
        // Add images if any
        if (extractImages) {
          const pageImages = content.images.find(i => i.page === page.page)?.images || [];
          pageImages.forEach((image, imgIndex) => {
            docContent += `
    <w:p>
      <w:r>
        <w:drawing>
          <wp:inline xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing">
            <wp:extent cx="${Math.round(image.width * 9525)}" cy="${Math.round(image.height * 9525)}"/>
            <wp:docPr id="${pageIndex}${imgIndex}" name="Picture ${pageIndex}${imgIndex}"/>
            <wp:cNvGraphicFramePr>
              <a:graphicFrameLocks xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" noChangeAspect="1"/>
            </wp:cNvGraphicFramePr>
            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
              <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
                <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
                  <pic:nvPicPr>
                    <pic:cNvPr id="0" name="Picture ${pageIndex}${imgIndex}"/>
                    <pic:cNvPicPr/>
                  </pic:nvPicPr>
                  <pic:blipFill>
                    <a:blip r:embed="rIdImage${pageIndex}${imgIndex}"/>
                    <a:stretch>
                      <a:fillRect/>
                    </a:stretch>
                  </pic:blipFill>
                  <pic:spPr>
                    <a:xfrm>
                      <a:off x="0" y="0"/>
                      <a:ext cx="${Math.round(image.width * 9525)}" cy="${Math.round(image.height * 9525)}"/>
                    </a:xfrm>
                    <a:prstGeom prst="rect">
                      <a:avLst/>
                    </a:prstGeom>
                  </pic:spPr>
                </pic:pic>
              </a:graphicData>
            </a:graphic>
          </wp:inline>
        </w:drawing>
      </w:r>
    </w:p>`;
          });
        }
        
        // Add page break if not last page
        if (pageIndex < content.text.length - 1) {
          docContent += `
    <w:p>
      <w:r>
        <w:br w:type="page"/>
      </w:r>
    </w:p>`;
        }
      });

      docContent += `
  </w:body>
</w:document>`;
      
      return docContent;
    }
    
    // Create RTF document
    function createRtfDocument(content, fileName) {
      const currentDate = new Date().toLocaleDateString();
      let rtfContent = `{\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033
{\\fonttbl{\\f0\\fnil\\fcharset0 Calibri;}}
{\\*\\generator FilePro PDF to Word Converter}\\viewkind4\\uc1 
\\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang9\\b\\fs32 Converted from PDF\\b0\\par
Original file: ${fileName.replace(/\\/g, '\\\\').replace(/{/g, '\\{').replace(/}/g, '\\}')}\\par
Converted on: ${currentDate}\\par\\par`;
      
      // Process each page's content
      content.text.forEach((page, pageIndex) => {
        rtfContent += `\\b Page ${pageIndex + 1}\\b0\\par`;
        
        // Add OCR text if available
        if (page.ocr && page.ocr.trim()) {
          rtfContent += `\\i\\cf1 OCR Text:\\i0\\cf0\\par`;
          rtfContent += `${escapeRtf(page.ocr)}\\par`;
        }
        
        // Process text content
        page.content.forEach(textGroup => {
          // Apply styling
          if (textGroup.font) {
            if (textGroup.font.includes('Bold')) {
              rtfContent += '\\b';
            }
            if (textGroup.font.includes('Italic')) {
              rtfContent += '\\i';
            }
          }
          
          if (textGroup.size) {
            rtfContent += `\\fs${Math.round(textGroup.size * 2)}`;
          }
          
          // Add text
          rtfContent += `${escapeRtf(textGroup.text)}\\par`;
          
          // Reset styles
          rtfContent += '\\b0\\i0\\fs22';
        });
        
        // Add tables if any
        const pageTables = content.tables.find(t => t.page === page.page)?.tables || [];
        pageTables.forEach(table => {
          rtfContent += '\\trowd\\trgaph108\\trleft0\\trqc';
          
          // Set column positions
          if (table.rows.length > 0) {
            table.rows[0].cells.forEach((cell, i) => {
              const cellEndPos = i < table.rows[0].cells.length - 1 ? 
                Math.round(table.rows[0].cells[i + 1].x * 15) : 
                Math.round((cell.x + cell.width) * 15);
              
              rtfContent += `\\cellx${cellEndPos}`;
            });
          }
          
          // Add rows
          table.rows.forEach(row => {
            row.cells.forEach(cell => {
              rtfContent += `\\intbl ${escapeRtf(cell.text)}\\cell`;
            });
            rtfContent += '\\row';
          });
          
          rtfContent += '\\pard\\par';
        });
        
        // Add page break if not last page
        if (pageIndex < content.text.length - 1) {
          rtfContent += '\\page\\par';
        }
      });
      
      rtfContent += '}';
      return rtfContent;
    }
    
    // Escape XML special characters
    function escapeXml(text) {
      return text.replace(/&/g, '&amp;')
                 .replace(/</g, '&lt;')
                 .replace(/>/g, '&gt;')
                 .replace(/"/g, '&quot;')
                 .replace(/'/g, '&apos;');
    }
    
    // Escape RTF special characters
    function escapeRtf(text) {
      return text.replace(/\\/g, '\\\\')
                 .replace(/{/g, '\\{')
                 .replace(/}/g, '\\}')
                 .replace(/\n/g, '\\par ')
                 .replace(/\t/g, '\\tab ');
    }
    
    // Add DOCX structure files
    function addDocxStructure(zip) {
      // Content Types
      zip.file("[Content_Types].xml", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Default Extension="png" ContentType="image/png"/>
  <Default Extension="jpeg" ContentType="image/jpeg"/>
  <Default Extension="jpg" ContentType="image/jpeg"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>`);
      
      // Main relationships
      zip.file("_rels/.rels", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`);
      
      // Document relationships
      let relsContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>`;
      
      // Add image relationships if any
      if (document.getElementById('extract-images').checked) {
        extractedContent.images.forEach((page, pageIndex) => {
          page.images.forEach((img, imgIndex) => {
            relsContent += `
  <Relationship Id="rIdImage${pageIndex}${imgIndex}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="media/image${pageIndex}${imgIndex}.png"/>`;
          });
        });
      }
      
      relsContent += `
</Relationships>`;
      
      zip.file("word/_rels/document.xml.rels", relsContent);
      
      // Styles
      zip.file("word/styles.xml", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
    <w:name w:val="Normal"/>
    <w:qFormat/>
    <w:rPr>
      <w:sz w:val="22"/>
      <w:lang w:val="en-US"/>
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading1">
    <w:name w:val="heading 1"/>
    <w:basedOn w:val="Normal"/>
    <w:next w:val="Normal"/>
    <w:qFormat/>
    <w:rPr>
      <w:b/>
      <w:sz w:val="32"/>
    </w:rPr>
  </w:style>
  <w:style w:type="table" w:styleId="TableGrid">
    <w:name w:val="Table Grid"/>
    <w:basedOn w:val="TableNormal"/>
    <w:uiPriority w:val="39"/>
    <w:rsid w:val="00F46D3A"/>
    <w:pPr>
      <w:spacing w:after="0" w:line="240" w:lineRule="auto"/>
    </w:pPr>
    <w:tblPr>
      <w:tblBorders>
        <w:top w:val="single" w:sz="4" w:space="0" w:color="auto"/>
        <w:left w:val="single" w:sz="4" w:space="0" w:color="auto"/>
        <w:bottom w:val="single" w:sz="4" w:space="0" w:color="auto"/>
        <w:right w:val="single" w:sz="4" w:space="0" w:color="auto"/>
        <w:insideH w:val="single" w:sz="4" w:space="0" w:color="auto"/>
        <w:insideV w:val="single" w:sz="4" w:space="0" w:color="auto"/>
      </w:tblBorders>
    </w:tblPr>
  </w:style>
</w:styles>`);
      
      // Add folder structure
      zip.folder("word");
      zip.folder("_rels");
    }
    
    // Add images to DOCX package
    function addImagesToDocx(zip, images) {
      const mediaFolder = zip.folder("word/media");
      
      images.forEach((page, pageIndex) => {
        page.images.forEach((img, imgIndex) => {
          if (img.dataUrl) {
            // Extract base64 data from data URL
            const base64Data = img.dataUrl.replace(/^data:image\/(png|jpeg);base64,/, '');
            mediaFolder.file(`image${pageIndex}${imgIndex}.png`, base64Data, { base64: true });
          }
        });
      });
    }
    
    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
      initEventListeners();
    });
  </script>
</body>
</html>